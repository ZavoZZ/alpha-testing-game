#!/usr/bin/env node

/**
 * Update .kilo/ Optimization Files
 * 
 * This script automatically updates the .kilo/ optimization files
 * by scanning the codebase for functions, files, and dependencies.
 * 
 * Usage: node scripts/update-kilo-files.js
 * 
 * Run this after making significant changes to the codebase.
 */

const fs = require('fs');
const path = require('path');

// Configuration
const CONFIG = {
  rootDir: process.cwd(),
  kiloDir: '.kilo',
  excludePatterns: [
    'node_modules',
    'qdrant_storage',
    '.git',
    'dist',
    'build'
  ]
};

// Utility functions
function walkDir(dir, callback) {
  if (!fs.existsSync(dir)) return;
  
  const files = fs.readdirSync(dir);
  for (const file of files) {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);
    
    if (CONFIG.excludePatterns.some(p => fullPath.includes(p))) continue;
    
    if (stat.isDirectory()) {
      walkDir(fullPath, callback);
    } else {
      callback(fullPath);
    }
  }
}

function extractFunctions(content, filePath) {
  const functions = [];
  
  // Match function declarations
  const funcRegex = /(?:function\s+(\w+)|(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s*)?\(?[^)]*\)?\s*=>|(\w+)\s*\([^)]*\)\s*{)/g;
  let match;
  
  while ((match = funcRegex.exec(content)) !== null) {
    const funcName = match[1] || match[2] || match[3];
    if (funcName && !funcName.startsWith('_')) {
      const lineNumber = content.substring(0, match.index).split('\n').length;
      functions.push({
        name: funcName,
        file: filePath,
        line: lineNumber
      });
    }
  }
  
  // Match route handlers
  const routeRegex = /router\.(get|post|put|delete|patch)\s*\(\s*['"`]([^'"`]+)['"`]/g;
  while ((match = routeRegex.exec(content)) !== null) {
    const lineNumber = content.substring(0, match.index).split('\n').length;
    functions.push({
      name: `${match[1].toUpperCase()} ${match[2]}`,
      file: filePath,
      line: lineNumber,
      type: 'endpoint'
    });
  }
  
  return functions;
}

// Main functions
function scanCodebase() {
  console.log('üîç Scanning codebase...');
  
  const functions = [];
  const files = [];
  
  const dirs = ['microservices', 'server', 'client', 'common'];
  
  for (const dir of dirs) {
    const fullPath = path.join(CONFIG.rootDir, dir);
    if (fs.existsSync(fullPath)) {
      walkDir(fullPath, (filePath) => {
        if (filePath.endsWith('.js') || filePath.endsWith('.jsx')) {
          try {
            const content = fs.readFileSync(filePath, 'utf8');
            const relativePath = path.relative(CONFIG.rootDir, filePath);
            
            files.push({
              path: relativePath,
              size: content.length
            });
            
            functions.push(...extractFunctions(content, relativePath));
          } catch (err) {
            console.warn(`‚ö†Ô∏è Could not read ${filePath}: ${err.message}`);
          }
        }
      });
    }
  }
  
  console.log(`‚úÖ Found ${functions.length} functions in ${files.length} files`);
  
  return { functions, files };
}

function updateFunctionIndex(data) {
  console.log('üìù Updating function-index.md...');
  
  const { functions } = data;
  
  // Group by category
  const categories = {
    'Authentication': functions.filter(f => f.file.includes('auth')),
    'Economy': functions.filter(f => f.file.includes('economy') || f.file.includes('Economy')),
    'Work': functions.filter(f => f.file.includes('Work') || f.file.includes('work')),
    'Inventory': functions.filter(f => f.file.includes('Inventory') || f.file.includes('inventory')),
    'Marketplace': functions.filter(f => f.file.includes('Marketplace') || f.file.includes('marketplace')),
    'Frontend': functions.filter(f => f.file.includes('client/')),
    'Admin': functions.filter(f => f.file.includes('admin') || f.file.includes('Admin')),
    'Database': functions.filter(f => f.file.includes('models/')),
    'API Endpoints': functions.filter(f => f.type === 'endpoint')
  };
  
  let content = `# Function Index - Quick Function Lookup

**Last Updated:** ${new Date().toISOString().split('T')[0]}  
**Purpose:** Find any function by name instantly without searching  
**Auto-generated by:** scripts/update-kilo-files.js

---

## üìä Statistics

- **Total Functions:** ${functions.length}
- **Categories:** ${Object.keys(categories).length}

---

`;

  for (const [category, funcs] of Object.entries(categories)) {
    if (funcs.length === 0) continue;
    
    content += `## ${category} Functions\n\n`;
    content += '| Function | File | Line |\n';
    content += '|----------|------|------|\n';
    
    for (const func of funcs.slice(0, 50)) {
      content += `| \`${func.name}\` | \`${func.file}\` | ~${func.line} |\n`;
    }
    
    if (funcs.length > 50) {
      content += `\n*...and ${funcs.length - 50} more*\n`;
    }
    
    content += '\n';
  }
  
  const outputPath = path.join(CONFIG.rootDir, CONFIG.kiloDir, 'function-index.md');
  fs.writeFileSync(outputPath, content);
  console.log(`‚úÖ Updated ${outputPath}`);
}

function updateCodeMap(data) {
  console.log('üìù Updating code-map.md...');
  
  const { files } = data;
  
  // Group by directory
  const dirs = {};
  for (const file of files) {
    const dir = path.dirname(file.path).split(path.sep)[0];
    if (!dirs[dir]) dirs[dir] = [];
    dirs[dir].push(file);
  }
  
  let content = `# Code Map - Quick File Navigation

**Last Updated:** ${new Date().toISOString().split('T')[0]}  
**Purpose:** Find any file or feature instantly without searching  
**Auto-generated by:** scripts/update-kilo-files.js

---

## üìä Statistics

- **Total Files:** ${files.length}
- **Directories:** ${Object.keys(dirs).length}

---

## üìÅ Files by Directory

`;

  for (const [dir, dirFiles] of Object.entries(dirs)) {
    content += `### ${dir}/\n\n`;
    content += '| File | Size |\n';
    content += '|------|------|\n';
    
    for (const file of dirFiles.slice(0, 30)) {
      const sizeKB = Math.round(file.size / 1024);
      content += `| \`${path.basename(file.path)}\` | ${sizeKB}KB |\n`;
    }
    
    if (dirFiles.length > 30) {
      content += `\n*...and ${dirFiles.length - 30} more files*\n`;
    }
    
    content += '\n';
  }
  
  const outputPath = path.join(CONFIG.rootDir, CONFIG.kiloDir, 'code-map.md');
  fs.writeFileSync(outputPath, content);
  console.log(`‚úÖ Updated ${outputPath}`);
}

function updateContext(data) {
  console.log('üìù Updating context.json...');
  
  const contextPath = path.join(CONFIG.rootDir, CONFIG.kiloDir, 'context.json');
  
  if (fs.existsSync(contextPath)) {
    const context = JSON.parse(fs.readFileSync(contextPath, 'utf8'));
    context.lastUpdated = new Date().toISOString().split('T')[0];
    context.statistics = {
      totalFiles: data.files.length,
      totalFunctions: data.functions.length
    };
    
    fs.writeFileSync(contextPath, JSON.stringify(context, null, 2));
    console.log(`‚úÖ Updated ${contextPath}`);
  } else {
    console.log('‚ö†Ô∏è context.json not found, skipping');
  }
}

function main() {
  console.log('üöÄ Starting .kilo/ files update...\n');
  
  // Ensure .kilo directory exists
  const kiloDir = path.join(CONFIG.rootDir, CONFIG.kiloDir);
  if (!fs.existsSync(kiloDir)) {
    fs.mkdirSync(kiloDir, { recursive: true });
  }
  
  // Scan codebase
  const data = scanCodebase();
  
  // Update files
  updateFunctionIndex(data);
  updateCodeMap(data);
  updateContext(data);
  
  console.log('\n‚ú® Update complete!');
  console.log('\nüìã Next steps:');
  console.log('   1. Review updated files in .kilo/');
  console.log('   2. Commit changes: git add .kilo/ && git commit -m "chore: update .kilo optimization files"');
}

// Run
main();